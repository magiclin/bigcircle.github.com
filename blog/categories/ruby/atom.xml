<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Hi, I’m dayuan]]></title>
  <link href="http://Bigcircle.github.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://Bigcircle.github.com/"/>
  <updated>2012-12-21T00:32:09+08:00</updated>
  <id>http://Bigcircle.github.com/</id>
  <author>
    <name><![CDATA[bigcircle]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[修改 GC 参数提高 Ruby 性能]]></title>
    <link href="http://Bigcircle.github.com/blog/improve-ruby-performance.html/"/>
    <updated>2012-11-15T15:50:00+08:00</updated>
    <id>http://Bigcircle.github.com/blog/improve-ruby-performance</id>
    <content type="html"><![CDATA[<p>最近看到有人提到最新的 ruby-patch 对性能有个很大的优化，不知是真是假，参考了老外一篇对 rvm 升级的<a href="http://astrails.com/blog/2012/11/13/rvm-install-patched-ruby-for-faster-rails-startup">介绍</a>，在本机上测试了下，感觉没什么大的变化，可能本机性能比生产环境要好很多，这点小的优化在单次测试中体现不出来，但在服务器上可能就有很大的性能提升。在此介绍下，希望能提供点帮助</p>

<ul>
  <li>更新 rvm 到最新版本获取最新的 patch</li>
</ul>

<p><code>ruby
rvm get head
rvm install 1.9.3 --patch falcon -n falcon
</code>
<!--more-->
如果直接给 1.9.3 打补丁可能会爆 <code>Patch 'falcon' not found</code> 的错误，这是因为 falcon 补丁还没有支持到最新的 ruby 版本，需要在本地找到支持的最新版本</p>

<p><code>
➜ ls $rvm_path/patches/ruby/1.9.3/*/*falcon* | sort
/Users/dayuan/.rvm/patches/ruby/1.9.3/p0/falcon.patch
/Users/dayuan/.rvm/patches/ruby/1.9.3/p125/falcon.patch
/Users/dayuan/.rvm/patches/ruby/1.9.3/p194/falcon.diff
/Users/dayuan/.rvm/patches/ruby/1.9.3/p286/falcon.diff
</code></p>

<p>可以看到最新的补丁支持到p286版本，刚好本地原装的就是这个版本</p>

<p><code>
➜ rvm install ruby-1.9.3-p286 --patch falcon -n falcon
# 安装完之后会重新编译一个ruby版本，而不是把原有版本覆盖
➜ ls ~/.rvm/rubies
default ruby-1.8.7-p370  ruby-1.9.3-p194  ruby-1.9.3-p286-falcon
</code></p>

<ul>
  <li>接着修改 GC 参数，添加到 .bashrc / .zshrc 中</li>
</ul>

<p><code>
export RUBY_HEAP_MIN_SLOTS=1000000
export RUBY_HEAP_FREE_MIN=500000
export RUBY_HEAP_SLOTS_INCREMENT=1000000
export RUBY_HEAP_SLOTS_GROWTH_FACTOR=1
export RUBY_GC_MALLOC_LIMIT=100000000
</code></p>

<p>GC参数设置，具体解释看 <a href="http://bbs.chinaunix.net/thread-3661069-1-1.html">这篇</a>，ruby 默认的GC参数都太小，上面的参数是 REE 官方建议的参数</p>

<p><code>
{
  RUBY_HEAP_MIN_SLOTS             =&gt; '初始堆大小，默认10000，越大需要占用的内存越多'
  RUBY_HEAP_FREE_MIN              =&gt; 'GC后可用的heap slot的最小值，默认4096，如果太小，就会按照下面2个参数分配新栈'
  RUBY_HEAP_SLOTS_INCREMENT       =&gt; '当Ruby需要开辟一片新的堆栈所需的数，默认是10000'
  RUBY_HEAP_SLOTS_GROWTH_FACTOR   =&gt; '当ruby需要新的堆栈的时候， 此参数做为一个乘数被用来计算这片新的堆栈的大小'
  RUBY_GC_MALLOC_LIMIT            =&gt; '允许不触发GC而分配的C数据结构的最大值，默认8000000 byte，设置的太低就会触发垃圾回收'
}
</code></p>

<p>看下 37single 和 twitter 的参数设置，差距上差不多</p>

<p>```
37signals
RUBY_HEAP_MIN_SLOTS=600000 
RUBY_GC_MALLOC_LIMIT=59000000 
RUBY_HEAP_FREE_MIN=100000 </p>

<p>twitter
RUBY_HEAP_MIN_SLOTS=500000 
RUBY_HEAP_SLOTS_INCREMENT=250000 
RUBY_HEAP_SLOTS_GROWTH_FACTOR=1 
RUBY_GC_MALLOC_LIMIT=50000000 
```</p>

<ul>
  <li>接下来测试下执行情况</li>
</ul>

<p>```
rvm use default
time <code>which rails</code> runner “puts :OK”
=&gt; <code>which rails</code> runner “puts :OK”  0.57s user 0.04s system 99% cpu 0.610 total</p>

<p>rvm use ruby-1.9.3-p286-falcon
time <code>which rails</code> runner “puts :OK”
<code>which rails</code> runner “puts :OK”  0.14s user 0.02s system 98% cpu 0.163 total
```</p>

<p>可以看到执行时间从 0.610s 到 0.163s 提升了300%。。。。虽然是毫秒级别的，但这个提示貌似有点凶猛，等什么时候修改到生产环境测试下是不是效率提示真的有这么大</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一些 Ruby 性能技巧]]></title>
    <link href="http://Bigcircle.github.com/blog/ruby-performance-tricks-you-should-know.html/"/>
    <updated>2012-09-04T19:57:00+08:00</updated>
    <id>http://Bigcircle.github.com/blog/ruby-performance-tricks-you-should-know</id>
    <content type="html"><![CDATA[<p>前两天看到这个 <a href="http://greyblake.com/blog/2012/09/02/ruby-perfomance-tricks/">ruby performance tricks</a> 作者总结的不错，但是很多人不喜欢看 e 文，刚好学习顺便翻译下
由于现在基本上都已经过渡到 1.9.3，测试数据均在 1.9.3 版本下测试</p>

<h6 id="rescue">不要在控制流中滥用rescue捕获异常</h6>

<p>```ruby
require ‘benchmark’</p>

<p>class Obj
  def with_condition
    respond_to?(:mythical_method) ? self.mythical_method : nil
  end</p>

<p>def with_rescue
    self.mythical_method
  rescue NoMethodError
    nil
  end
end</p>

<p>obj = Obj.new
N = 10<em>000</em>000</p>

<p>puts RUBY_DESCRIPTION</p>

<p>Benchmark.bm(15, “rescue/condition”) do |x|
  rescue_report     = x.report(“rescue:”)    { N.times { obj.with_rescue  } }
  condition_report  = x.report(“condition:”) { N.times { obj.with_if      } }
  [rescue_report / condition_report]
end
```</p>

<p>跑分数据可以看出使用了rescue，性能损失超过43倍</p>

<!--more-->

<p><code>
ruby 1.9.3p194 (2012-04-20 revision 35410) [x86_64-linux]
                        user     system      total        real
rescue:           111.530000   2.650000 114.180000 (115.837103)
condition:          2.620000   0.010000   2.630000 (  2.633154)
rescue/condition:  42.568702 265.000000        NaN ( 43.991767)
</code></p>

<p>google 了下发现不光 Ruby 会有这个问题，C，C++，Java 中也都会有很大的性能问题，原因大概是因为异常捕获这个操作本身就很慢，<a href="http://www.simonecarletti.com/blog/2010/01/how-slow-are-ruby-exceptions/">这</a> 有一份比较详细的测试，对比使用 exception 在速度上的劣势。当然该捕捉的时候还是要捕捉的，只是不要滥用</p>

<h6 id="section">使用 « 拼接字符串</h6>

<p>这个tip可能大家都听过，估计平时也都是这么用的，为什么用 « 不要用 += 呢，看这个测试</p>

<p>```
require ‘benchmark’</p>

<p>N = 1000
BASIC_LENGTH = 10</p>

<p>5.times do |factor|
  length = BASIC_LENGTH * (10 ** factor)
  puts “_” * 60 + “\nLENGTH: #{length}”</p>

<p>Benchmark.bm(10, ‘+= VS «’) do |x|
    concat_report = x.report(“+=”)  do
      str1 = “”
      str2 = “s” * length
      N.times { str1 += str2 }
    end</p>

<pre><code>modify_report = x.report("&lt;&lt;")  do
  str1 = "s"
  str2 = "s" * length
  N.times { str1 &lt;&lt; str2 }
end

[concat_report / modify_report]   end end ```
</code></pre>

<p>结果如下</p>

<p><code>
____________________________________________________________
LENGTH: 10
                 user     system      total        real
+=           0.000000   0.000000   0.000000 (  0.004671)
&lt;&lt;           0.000000   0.000000   0.000000 (  0.000176)
+= VS &lt;&lt;          NaN        NaN        NaN ( 26.508796)
____________________________________________________________
LENGTH: 100
                 user     system      total        real
+=           0.020000   0.000000   0.020000 (  0.022995)
&lt;&lt;           0.000000   0.000000   0.000000 (  0.000226)
+= VS &lt;&lt;          Inf        NaN        NaN (101.845829)
____________________________________________________________
LENGTH: 1000
                 user     system      total        real
+=           0.270000   0.120000   0.390000 (  0.390888)
&lt;&lt;           0.000000   0.000000   0.000000 (  0.001730)
+= VS &lt;&lt;          Inf        Inf        NaN (225.920077)
____________________________________________________________
LENGTH: 10000
                 user     system      total        real
+=           3.660000   1.570000   5.230000 (  5.233861)
&lt;&lt;           0.000000   0.010000   0.010000 (  0.015099)
+= VS &lt;&lt;          Inf 157.000000        NaN (346.629692)
____________________________________________________________
LENGTH: 100000
                 user     system      total        real
+=          31.270000  16.990000  48.260000 ( 48.328511)
&lt;&lt;           0.050000   0.050000   0.100000 (  0.105993)
+= VS &lt;&lt;   625.400000 339.800000        NaN (455.961373)
</code></p>

<p>从结果可以看出，字符串比较短时就差25倍，随着字符串长度的增加，性能差距也越来越大
为什么作用相同的操作性能方便差距这么大呢，看这个例子</p>

<p>```
str1 = “first”
str2 = “second”
str1.object_id       # =&gt; 16241320</p>

<p>str1 += str2    # str1 = str1 + str2
str1.object_id  # =&gt; 16241240, id is changed</p>

<p>str1 « str2
str1.object_id  # =&gt; 16241240, id is the same
```</p>

<p>当使用 += 时会在内存中多复制一份原始字符串，生成 str1 + str2 临时object覆盖掉 str1, 因此操作完之后 str1 的 object_id 发生了变化，而 « 是直接在原 str1 上进行操作，操作完之后 object_id 没有发生变化</p>

<p>+= 还会导致内存中存在大量多余的string object，GC 触发垃圾回收也会消耗掉许多时间</p>

<h6 id="section-1">注意使用迭代</h6>

<p>假设你需要写个函数把数组转换成一个 hash, 就像这样</p>

<p><code>
func([1, 2, 3])  # =&gt; {1 =&gt; 1, 2 =&gt; 2, 3 =&gt; 3}
</code></p>

<p>一个可以解决问题的做法</p>

<p><code>
def func(array)
  array.inject({}) { |h, e| h.merge(e =&gt; e) }
end
</code></p>

<p>这个方法的时间复杂度是 O(n2)，当数组很大时速度会非常慢，稍作调整，时间复杂度 O(n)</p>

<p><code>
def func(array)
  array.inject({}) { |h, e| h[e] = e; h }
end
</code></p>

<p>看下测试时间</p>

<p>```
require ‘benchmark’</p>

<p>def n_func(array)
  array.inject({}) { |h, e| h[e] = e; h }
end</p>

<p>def n2_func(array)
  array.inject({}) { |h, e| h.merge(e =&gt; e) }
end</p>

<p>BASE_SIZE = 10</p>

<p>4.times do |factor|
  size   = BASE_SIZE * (10 ** factor)
  params = (0..size).to_a
  puts “_” * 60 + “\nSIZE: #{size}”
  Benchmark.bm(10) do |x|
    x.report(“O(n)” ) { n_func(params)  }
    x.report(“O(n2)”) { n2_func(params) }
  end
end
```</p>

<p>从时间上看虽然都消耗不大，但是还是有明显性能差距的，记住不要用迭代做大规模计算</p>

<p><code>
SIZE: 10
                user     system      total        real
O(n)        0.000000   0.000000   0.000000 (  0.000014)
O(n2)       0.000000   0.000000   0.000000 (  0.000033)
____________________________________________________________
SIZE: 100
                user     system      total        real
O(n)        0.000000   0.000000   0.000000 (  0.000043)
O(n2)       0.000000   0.000000   0.000000 (  0.001070)
____________________________________________________________
SIZE: 1000
                user     system      total        real
O(n)        0.000000   0.000000   0.000000 (  0.000347)
O(n2)       0.130000   0.000000   0.130000 (  0.127638)
____________________________________________________________
SIZE: 10000
                user     system      total        real
O(n)        0.020000   0.000000   0.020000 (  0.019067)
O(n2)      17.850000   0.080000  17.930000 ( 17.983827)
</code></p>

<h6 id="method">使用　method!</h6>

<p>很多时候直接用 method 和 使用 method! 都在做同样的事，不同的是用 method! 不会重新复制一份副本，使用 method! 速度会快点</p>

<p>```
require ‘benchmark’</p>

<p>def merge!(array)
  array.inject({}) { |h, e| h.merge!(e =&gt; e) }
end</p>

<p>def merge(array)
  array.inject({}) { |h, e| h.merge(e =&gt; e) }
end</p>

<p>N = 10_000
array = (0..N).to_a</p>

<p>Benchmark.bm(10) do |x|
  x.report(“merge!”) { merge!(array) }
  x.report(“merge”)  { merge(array)  }
end
```</p>

<p>这个差距有点大</p>

<p><code>
                 user     system      total        real
merge!       0.010000   0.000000   0.010000 (  0.011370)
merge       17.710000   0.000000  17.710000 ( 17.840856)
</code></p>

<h6 id="section-2">使用实例变量</h6>

<p>直接访问实例变量是通过 accessor 访问速度的2倍</p>

<p>```
require ‘benchmark’</p>

<p>class Metric
  attr_accessor :var</p>

<p>def initialize(n)
    @n   = n
    @var = 22
  end</p>

<p>def run
    Benchmark.bm(10) do |x|
      x.report(“@var”) { @n.times { @var } }
      x.report(“var” ) { @n.times { var  } }
      x.report(“@var =”)     { @n.times {|i| @var = i     } }
      x.report(“self.var =”) { @n.times {|i| self.var = i } }
    end
  end
end</p>

<p>metric = Metric.new(100<em>000</em>000)
metric.run
```</p>

<p><code>
                 user     system      total        real
@var         6.980000   0.010000   6.990000 (  7.193725)
var         13.040000   0.000000  13.040000 ( 13.131711)
@var =       7.960000   0.000000   7.960000 (  8.242603)
self.var =  14.910000   0.010000  14.920000 ( 15.960125)
</code></p>

<h6 id="section-3">平行的任务速度比分开执行慢</h6>

<p>```
require ‘benchmark’</p>

<p>N = 10<em>000</em>000</p>

<p>Benchmark.bm(15) do |x|
  x.report(‘parallel’) do
    N.times do
      a, b = 10, 20
    end
  end</p>

<p>x.report(‘consequentially’) do |x|
    N.times do
      a = 10
      b = 20
    end
  end
end
```</p>

<p>速度差距1倍以上，我平时就喜欢为了少写几行平行赋值，看来这个习惯要改下啦</p>

<p><code>
                      user     system      total        real
parallel          1.900000   0.000000   1.900000 (  1.928063)
consequentially   0.880000   0.000000   0.880000 (  0.879675)
</code></p>

<h6 id="definemethod--classeval">动态定义方法比较 define_method 和 class_eval</h6>

<p>在动态定义方法时是用 class_eval string 快还是 defing_method 快呢</p>

<p>```
require ‘benchmark’</p>

<p>class Metric
  N = 1<em>000</em>000</p>

<p>def self.class_eval_with_string
    N.times do |i|
      class_eval(«-eorb, <strong>FILE</strong>, <strong>LINE</strong> + 1)
        def smeth_#{i}
          #{i}
        end
      eorb
    end
  end</p>

<p>def self.with_define_method
    N.times do |i|
      define_method(“dmeth_#{i}”) do
        i
      end
    end
  end
end</p>

<p>Benchmark.bm(22) do |x|
  x.report(“class_eval with string”) { Metric.class_eval_with_string }
  x.report(“define_method”)          { Metric.with_define_method     }</p>

<p>metric = Metric.new
  x.report(“string method”)  { Metric::N.times { metric.smeth<em>1 } }
  x.report(“dynamic method”) { Metric::N.times { metric.dmeth</em>1 } }
end
```</p>

<p>结果显示 define_method 比 class_eval string 快3倍以上，class_eval 虽然在方法生成上慢却应该优先使用，因为它生成的方法执行起来更快</p>

<p><code>
                             user     system      total        real
class_eval with string 219.840000   0.720000 220.560000 (221.933074)
define_method           61.280000   0.240000  61.520000 ( 62.070911)
string method            0.110000   0.000000   0.110000 (  0.111433)
dynamic method           0.150000   0.000000   0.150000 (  0.156537)
</code></p>

<p>不积跬步，无以至千里。虽然这些都是一些性能方面的小技巧，但累积多了也能对性能有很大的优化</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初识Octopress]]></title>
    <link href="http://Bigcircle.github.com/blog/chu-shi-octopress.html/"/>
    <updated>2012-08-16T00:37:00+08:00</updated>
    <id>http://Bigcircle.github.com/blog/chu-shi-octopress</id>
    <content type="html"><![CDATA[<p>其实久仰 Octopress 大名已久，只是一直懒得弄，最近找工作顺便搭个 Blog 开始写点所学所想。
折腾了下 Jekyll，也是需要自己去折腾主题，先拿 Octopress 用着，等什么时候闲点再把主题修修</p>

<h3 id="octopress">octopress</h3>

<p>基于 Jekyll 和 github-page 的一套静态 blog 系统，可以通过 theme/plugin 定制自己喜欢的功能/样式，采用markdown编写，让写作从此简单。深受各大DS欢迎，也是伸手党的最爱，当然也为我等小折腾提供了便利，不用再考虑什么托管，样式，域名等一大堆繁琐的东西。下面把这次配置过程简单总结下，也为可能需要的朋友提供下指引，都是重复造轮子，就看大家喜欢哪款了。</p>

<h6 id="rvm--ruby">安装 rvm &amp; ruby</h6>

<p><code>bash
    curl -L https://get.rvm.io | bash -s stable
	# 我用的 zsh ,根据自身情况换成 .bash_profile
    echo "
    # RVM
    [[ -s '/Users/`whoami`/.rvm/scripts/rvm' ]] &amp;&amp; source '/Users/`whoami`/.rvm/scripts/rvm'
    [[ -s '$HOME/.rvm/scripts/rvm' ]] &amp;&amp; . '$HOME/.rvm/scripts/rvm" &gt;&gt; ~/.zshrc
    source ~/.zshrc				# 使刚才配置生效
    rvm install 1.9.3
    rvm use 1.9.3 --default			# rvm安装1.9.3版本ruby，并默认使用该版本
</code></p>

<h6 id="octopress-">复制 Octopress 到本地</h6>

<!-- more -->

<p><code>
    git clone git clone git://github.com/imathis/octopress.git myblog
    cd myblog
    bundle install				# 安装所需 gem
    rake install				# 安装默认主题
    rake preview				# 本地预览, http://localhost:4000
</code></p>

<h6 id="github">部署到 github</h6>

<p>```
    rake setup_github_pages
	# 按提示输入 github 上对应仓库，注意替换 your_name，此时会建立一个 origin 远程仓库，对应你项目目录下的 master 分支
    git@github.com:your_username/your_username.github.com.git
    rake generate				# 将所有内容生成静态文件
    rake deploy 				# 部署到github上</p>

<pre><code># 创建 source 分支 用于保存作文和配置文件
git add .
git commit -m 'create source branch'
git push origin source ```
</code></pre>

<p>OK，到此大概流程差不多就这样了，大家可能会遇到各种问题，这个时候 Google娘 就是你最好的帮手了。
不知不觉已经夜深人静了，明天把 Disqus 加上就可以留个小言啦。</p>

]]></content>
  </entry>
  
</feed>
