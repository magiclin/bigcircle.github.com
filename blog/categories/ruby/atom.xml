<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Hi, I’m dayuan]]></title>
  <link href="http://Bigcircle.github.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://Bigcircle.github.com/"/>
  <updated>2012-09-16T16:17:27+08:00</updated>
  <id>http://Bigcircle.github.com/</id>
  <author>
    <name><![CDATA[bigcircle]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[一些 Ruby 性能技巧]]></title>
    <link href="http://Bigcircle.github.com/blog/ruby-performance-tricks-you-should-know.html/"/>
    <updated>2012-09-04T19:57:00+08:00</updated>
    <id>http://Bigcircle.github.com/blog/ruby-performance-tricks-you-should-know</id>
    <content type="html"><![CDATA[<p>前两天看到这个 <a href="http://greyblake.com/blog/2012/09/02/ruby-perfomance-tricks/">ruby performance tricks</a> 作者总结的不错，但是很多人不喜欢看 e 文，刚好学习顺便翻译下
由于现在基本上都已经过渡到 1.9.3，测试数据均在 1.9.3 版本下测试
<!--more--></p>

<h6 id="rescue">不要在控制流中滥用rescue捕获异常</h6>

<p>```ruby
require ‘benchmark’</p>

<p>class Obj
  def with_condition
    respond_to?(:mythical_method) ? self.mythical_method : nil
  end</p>

<p>def with_rescue
    self.mythical_method
  rescue NoMethodError
    nil
  end
end</p>

<p>obj = Obj.new
N = 10<em>000</em>000</p>

<p>puts RUBY_DESCRIPTION</p>

<p>Benchmark.bm(15, “rescue/condition”) do |x|
  rescue_report     = x.report(“rescue:”)    { N.times { obj.with_rescue  } }
  condition_report  = x.report(“condition:”) { N.times { obj.with_if      } }
  [rescue_report / condition_report]
end
```</p>

<p>跑分数据可以看出使用了rescue，性能损失超过43倍</p>

<p><code>
ruby 1.9.3p194 (2012-04-20 revision 35410) [x86_64-linux]
                        user     system      total        real
rescue:           111.530000   2.650000 114.180000 (115.837103)
condition:          2.620000   0.010000   2.630000 (  2.633154)
rescue/condition:  42.568702 265.000000        NaN ( 43.991767)
</code></p>

<p>google 了下发现不光 Ruby 会有这个问题，C，C++，Java 中也都会有很大的性能问题，原因大概是因为异常捕获这个操作本身就很慢，<a href="http://www.simonecarletti.com/blog/2010/01/how-slow-are-ruby-exceptions/">这</a> 有一份比较详细的测试，对比使用 exception 在速度上的劣势。当然该捕捉的时候还是要捕捉的，只是不要滥用</p>

<h6 id="section">使用 « 拼接字符串</h6>

<p>这个tip可能大家都听过，估计平时也都是这么用的，为什么用 « 不要用 += 呢，看这个测试</p>

<p>```
require ‘benchmark’</p>

<p>N = 1000
BASIC_LENGTH = 10</p>

<p>5.times do |factor|
  length = BASIC_LENGTH * (10 ** factor)
  puts “_” * 60 + “\nLENGTH: #{length}”</p>

<p>Benchmark.bm(10, ‘+= VS «’) do |x|
    concat_report = x.report(“+=”)  do
      str1 = “”
      str2 = “s” * length
      N.times { str1 += str2 }
    end</p>

<pre><code>modify_report = x.report("&lt;&lt;")  do
  str1 = "s"
  str2 = "s" * length
  N.times { str1 &lt;&lt; str2 }
end

[concat_report / modify_report]   end end ```
</code></pre>

<p>结果如下</p>

<p><code>
____________________________________________________________
LENGTH: 10
                 user     system      total        real
+=           0.000000   0.000000   0.000000 (  0.004671)
&lt;&lt;           0.000000   0.000000   0.000000 (  0.000176)
+= VS &lt;&lt;          NaN        NaN        NaN ( 26.508796)
____________________________________________________________
LENGTH: 100
                 user     system      total        real
+=           0.020000   0.000000   0.020000 (  0.022995)
&lt;&lt;           0.000000   0.000000   0.000000 (  0.000226)
+= VS &lt;&lt;          Inf        NaN        NaN (101.845829)
____________________________________________________________
LENGTH: 1000
                 user     system      total        real
+=           0.270000   0.120000   0.390000 (  0.390888)
&lt;&lt;           0.000000   0.000000   0.000000 (  0.001730)
+= VS &lt;&lt;          Inf        Inf        NaN (225.920077)
____________________________________________________________
LENGTH: 10000
                 user     system      total        real
+=           3.660000   1.570000   5.230000 (  5.233861)
&lt;&lt;           0.000000   0.010000   0.010000 (  0.015099)
+= VS &lt;&lt;          Inf 157.000000        NaN (346.629692)
____________________________________________________________
LENGTH: 100000
                 user     system      total        real
+=          31.270000  16.990000  48.260000 ( 48.328511)
&lt;&lt;           0.050000   0.050000   0.100000 (  0.105993)
+= VS &lt;&lt;   625.400000 339.800000        NaN (455.961373)
</code></p>

<p>从结果可以看出，字符串比较短时就差25倍，随着字符串长度的增加，性能差距也越来越大
为什么作用相同的操作性能方便差距这么大呢，看这个例子</p>

<p>```
str1 = “first”
str2 = “second”
str1.object_id       # =&gt; 16241320</p>

<p>str1 += str2    # str1 = str1 + str2
str1.object_id  # =&gt; 16241240, id is changed</p>

<p>str1 « str2
str1.object_id  # =&gt; 16241240, id is the same
```</p>

<p>当使用 += 时会在内存中多复制一份原始字符串，生成 str1 + str2 临时object覆盖掉 str1, 因此操作完之后 str1 的 object_id 发生了变化，而 « 是直接在原 str1 上进行操作，操作完之后 object_id 没有发生变化</p>

<p>+= 还会导致内存中存在大量多余的string object，GC 触发垃圾回收也会消耗掉许多时间</p>

<h6 id="section-1">注意使用迭代</h6>

<p>假设你需要写个函数把数组转换成一个 hash, 就像这样</p>

<p><code>
func([1, 2, 3])  # =&gt; {1 =&gt; 1, 2 =&gt; 2, 3 =&gt; 3}
</code></p>

<p>一个可以解决问题的做法</p>

<p><code>
def func(array)
  array.inject({}) { |h, e| h.merge(e =&gt; e) }
end
</code></p>

<p>这个方法的时间复杂度是 O(n2)，当数组很大时速度会非常慢，稍作调整，时间复杂度 O(n)</p>

<p><code>
def func(array)
  array.inject({}) { |h, e| h[e] = e; h }
end
</code></p>

<p>看下测试时间</p>

<p>```
require ‘benchmark’</p>

<p>def n_func(array)
  array.inject({}) { |h, e| h[e] = e; h }
end</p>

<p>def n2_func(array)
  array.inject({}) { |h, e| h.merge(e =&gt; e) }
end</p>

<p>BASE_SIZE = 10</p>

<p>4.times do |factor|
  size   = BASE_SIZE * (10 ** factor)
  params = (0..size).to_a
  puts “_” * 60 + “\nSIZE: #{size}”
  Benchmark.bm(10) do |x|
    x.report(“O(n)” ) { n_func(params)  }
    x.report(“O(n2)”) { n2_func(params) }
  end
end
```</p>

<p>从时间上看虽然都消耗不大，但是还是有明显性能差距的，记住不要用迭代做大规模计算</p>

<p><code>
SIZE: 10
                user     system      total        real
O(n)        0.000000   0.000000   0.000000 (  0.000014)
O(n2)       0.000000   0.000000   0.000000 (  0.000033)
____________________________________________________________
SIZE: 100
                user     system      total        real
O(n)        0.000000   0.000000   0.000000 (  0.000043)
O(n2)       0.000000   0.000000   0.000000 (  0.001070)
____________________________________________________________
SIZE: 1000
                user     system      total        real
O(n)        0.000000   0.000000   0.000000 (  0.000347)
O(n2)       0.130000   0.000000   0.130000 (  0.127638)
____________________________________________________________
SIZE: 10000
                user     system      total        real
O(n)        0.020000   0.000000   0.020000 (  0.019067)
O(n2)      17.850000   0.080000  17.930000 ( 17.983827)
</code></p>

<h6 id="method">使用　method!</h6>

<p>很多时候直接用 method 和 使用 method! 都在做同样的事，不同的是用 method! 不会重新复制一份副本，使用 method! 速度会快点</p>

<p>```
require ‘benchmark’</p>

<p>def merge!(array)
  array.inject({}) { |h, e| h.merge!(e =&gt; e) }
end</p>

<p>def merge(array)
  array.inject({}) { |h, e| h.merge(e =&gt; e) }
end</p>

<p>N = 10_000
array = (0..N).to_a</p>

<p>Benchmark.bm(10) do |x|
  x.report(“merge!”) { merge!(array) }
  x.report(“merge”)  { merge(array)  }
end
```</p>

<p>这个差距有点大</p>

<p><code>
                 user     system      total        real
merge!       0.010000   0.000000   0.010000 (  0.011370)
merge       17.710000   0.000000  17.710000 ( 17.840856)
</code></p>

<h6 id="section-2">使用实例变量</h6>

<p>直接访问实例变量是通过 accessor 访问速度的2倍</p>

<p>```
require ‘benchmark’</p>

<p>class Metric
  attr_accessor :var</p>

<p>def initialize(n)
    @n   = n
    @var = 22
  end</p>

<p>def run
    Benchmark.bm(10) do |x|
      x.report(“@var”) { @n.times { @var } }
      x.report(“var” ) { @n.times { var  } }
      x.report(“@var =”)     { @n.times {|i| @var = i     } }
      x.report(“self.var =”) { @n.times {|i| self.var = i } }
    end
  end
end</p>

<p>metric = Metric.new(100<em>000</em>000)
metric.run
```</p>

<p><code>
                 user     system      total        real
@var         6.980000   0.010000   6.990000 (  7.193725)
var         13.040000   0.000000  13.040000 ( 13.131711)
@var =       7.960000   0.000000   7.960000 (  8.242603)
self.var =  14.910000   0.010000  14.920000 ( 15.960125)
</code></p>

<h6 id="section-3">平行的任务速度比分开执行慢</h6>

<p>```
require ‘benchmark’</p>

<p>N = 10<em>000</em>000</p>

<p>Benchmark.bm(15) do |x|
  x.report(‘parallel’) do
    N.times do
      a, b = 10, 20
    end
  end</p>

<p>x.report(‘consequentially’) do |x|
    N.times do
      a = 10
      b = 20
    end
  end
end
```</p>

<p>速度差距1倍以上，我平时就喜欢为了少写几行平行赋值，看来这个习惯要改下啦</p>

<p><code>
                      user     system      total        real
parallel          1.900000   0.000000   1.900000 (  1.928063)
consequentially   0.880000   0.000000   0.880000 (  0.879675)
</code></p>

<h6 id="definemethod--classeval">动态定义方法比较 define_method 和 class_eval</h6>

<p>在动态定义方法时是用 class_eval string 快还是 defing_method 快呢</p>

<p>```
require ‘benchmark’</p>

<p>class Metric
  N = 1<em>000</em>000</p>

<p>def self.class_eval_with_string
    N.times do |i|
      class_eval(«-eorb, <strong>FILE</strong>, <strong>LINE</strong> + 1)
        def smeth_#{i}
          #{i}
        end
      eorb
    end
  end</p>

<p>def self.with_define_method
    N.times do |i|
      define_method(“dmeth_#{i}”) do
        i
      end
    end
  end
end</p>

<p>Benchmark.bm(22) do |x|
  x.report(“class_eval with string”) { Metric.class_eval_with_string }
  x.report(“define_method”)          { Metric.with_define_method     }</p>

<p>metric = Metric.new
  x.report(“string method”)  { Metric::N.times { metric.smeth<em>1 } }
  x.report(“dynamic method”) { Metric::N.times { metric.dmeth</em>1 } }
end
```</p>

<p>结果显示 define_method 比 class_eval string 快3倍以上，class_eval 虽然在方法生成上慢却应该优先使用，因为它生成的方法执行起来更快</p>

<p><code>
                             user     system      total        real
class_eval with string 219.840000   0.720000 220.560000 (221.933074)
define_method           61.280000   0.240000  61.520000 ( 62.070911)
string method            0.110000   0.000000   0.110000 (  0.111433)
dynamic method           0.150000   0.000000   0.150000 (  0.156537)
</code></p>

<p>不积跬步，无以至千里。虽然这些都是一些性能方面的小技巧，但累积多了也能对性能有很大的优化</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sublime Text 2 使用 RVM ]]></title>
    <link href="http://Bigcircle.github.com/blog/add-rvm-ruby-path-to-sublime-text-2.html/"/>
    <updated>2012-09-01T13:43:00+08:00</updated>
    <id>http://Bigcircle.github.com/blog/add-rvm-ruby-path-to-sublime-text-2</id>
    <content type="html"><![CDATA[<p>用 Sublime Text 2 的同学使用 rvm 时会发现内置的可执行 ruby build 不可用了或者还是默认执行系统自带的 ruby-1.8.7 版本，当执行的脚本中用到 1.9.2 新语法的时候可能会被错，这个时候就需要切换到 rvm 版本控制的 ruby
<!--more-->
默认自带的 build 目录位于</p>

<p><code>c
~/Library/Application\ Support/Sublime\ Text\ 2/Packages/Ruby/Ruby.sublime-build
</code></p>

<p>默认的配置是这样的</p>

<p><code>
"cmd": ["ruby", "$file"],
"file_regex": "^(...*?):([0-9]*):?([0-9]*)",
"selector": "source.ruby"
</code></p>

<p>切换到 rvm 只需要改 cmd - ruby 指向路径， -KU 增加对中文输出支持，当然文件类型也要求是 utf-8</p>

<p><code>
"cmd": ["/Users/yourname/.rvm/bin/rvm-auto-ruby", "-KU", "$file"]
</code></p>

<p>你也可以自己改成 rvm 默认的 default ruby</p>

<p>```c
which ruby</p>

<p>=&gt; /Users/yourname/.rvm/rubies/ruby-1.9.3-p194/bin/ruby
```</p>

<p>默认执行快捷键是 <code>⌘ + b</code> / <code>F7</code>，可以自己定义成喜欢的按键</p>

<p><code>
{ "keys": ["super+b"], "command": "build" },
</code></p>

<p>如何构建不用语言的 build，参考 <a href="http://addyosmani.com/blog/custom-sublime-text-build-systems-for-popular-tools-and-languages/">这篇</a>，差不多列举全了，构造方式也很简单</p>

<hr />

<p>另外推荐个我最常用的快捷键</p>

<ul>
  <li>在打开的几个标签之间前后切换。当打开很多标签时，又不喜欢用鼠标点来点去的可以试下这个</li>
</ul>

<p><code>
{ "keys": ["super+1"], "command": "prev_view" },
{ "keys": ["super+2"], "command": "next_view" },
</code></p>

<p>这个快捷键同样适用于设置 Chrome/TotalFinder/iTerm 等能打开多标签的app，设置方式如下</p>

<p><img src="http://m2.img.libdd.com/farm4/2012/0901/15/57756B60A70B4B4D6BEE07D177C25C55C856F5189977_500_448.jpg" alt="" /></p>

<p>其他我定义的快捷键都在 <a href="https://github.com/Bigcircle/config/blob/master/sublime/User/Default%20(OSX).sublime-keymap">这</a>，有需要的可以去淘几个</p>

<p>工欲善其事，必先利其器，利用好工具可以给开发带来很大的便利，节省很多时间</p>
]]></content>
  </entry>
  
</feed>
